import sys
sys.path.insert(1, '/home/PMO/airflow/dags')
from pyspark.sql import SparkSession
from pyspark import SparkConf, conf
from pyspark.sql.types import *
import pandas as pd
from datetime import * 
import Connections as conn
import ETLFunctions as fx
from time import * 
from airflow import DAG
from airflow.operators.python_operator import PythonOperator
import random 
import sys 
import pendulum

load_connection_string = "jdbc:mysql://10.10.11.242:3306/RME_TEST?useUnicode=true&characterEncoding=UTF-8"


RME_All_Inventories_Value_query="""(
   SELECT
	CIQT.ORGANIZATION_ID,
	MSI.description DESCRIPTION,
	MSI.PRIMARY_UOM_CODE UOM_CODE,
	ROUND (SUM (CIQT.ROLLBACK_QTY),
	4) STK_QTY,
	0 INT_QTY,
	0 RCV_QTY,
	ROUND (
                SUM (CIQT.ROLLBACK_QTY)
              * DECODE (SUB.ASSET_INVENTORY,
	1,
	CICT.ITEM_COST,
	0)
              * 1
              / 0.0001)
         * 0.0001
            STK_VALUE,
	0 INT_VALUE,
	0 RCV_VALUE
FROM
	XXXRME_CST_INV_QTY_TEMP CIQT,
	XXXRME_CST_INV_COST_TEMP CICT,
	MTL_PARAMETERS MP,
	MTL_SYSTEM_ITEMS_B MSI,
	apps.MTL_CATEGORIES MC,
	MTL_SECONDARY_INVENTORIES SUB
WHERE
	CIQT.QTY_SOURCE IN (3, 4, 5)
	AND CICT.COST_SOURCE IN (1, 2)
	AND CICT.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND CICT.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND ( MP.PRIMARY_COST_METHOD = 1
		OR CICT.COST_GROUP_ID = CIQT.COST_GROUP_ID)
	-- should we split?
	AND MP.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND SUB.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND SUB.SECONDARY_INVENTORY_NAME = CIQT.SUBINVENTORY_CODE
	AND MSI.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND MSI.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND MC.CATEGORY_ID = CIQT.CATEGORY_ID
GROUP BY
	CIQT.ORGANIZATION_ID,
	MSI.description,
	MSI.PRIMARY_UOM_CODE,
	DECODE (SUB.ASSET_INVENTORY,
	1,
	CICT.ITEM_COST,
	0)
HAVING
	SUM (CIQT.ROLLBACK_QTY) <> 0
UNION ALL
  SELECT
	CIQT.ORGANIZATION_ID,
	MSI.description DESCRIPTION,
	MSI.PRIMARY_UOM_CODE UOM_CODE,
	0 STK_QTY,
	ROUND (SUM (CIQT.ROLLBACK_QTY),
	4) INT_QTY,
	0 RCV_QTY,
	0 STK_VALUE,
	ROUND (SUM (CIQT.ROLLBACK_QTY) * CICT.ITEM_COST * 1 / 0.0001) * 0.0001
            INT_VALUE,
	0 RCV_VALUE
FROM
	XXXRME_CST_INV_QTY_TEMP CIQT,
	XXXRME_CST_INV_COST_TEMP CICT,
	MTL_PARAMETERS MP,
	MTL_SYSTEM_ITEMS_B MSI,
	apps.MTL_CATEGORIES MC
WHERE
	CIQT.QTY_SOURCE IN (6, 7, 8)
	--      AND CICT.ORGANIZATION_ID = NVL ( :P_ORG_ID, CICT.ORGANIZATION_ID)
	AND CICT.COST_SOURCE IN (1, 2)
	AND CICT.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND CICT.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND CICT.COST_GROUP_ID = CIQT.COST_GROUP_ID /*BUG 7138456: removed unnecesary join for the cost method*/
	AND MP.PRIMARY_COST_METHOD <> 1
	AND MP.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND MSI.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND MSI.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND MC.CATEGORY_ID = CIQT.CATEGORY_ID
GROUP BY
	CIQT.ORGANIZATION_ID,
	MSI.description,
	MSI.PRIMARY_UOM_CODE,
	CICT.ITEM_COST
HAVING
	SUM (CIQT.ROLLBACK_QTY) <> 0
UNION ALL
  SELECT
	CIQT.ORGANIZATION_ID,
	MSI.description DESCRIPTION,
	MSI.PRIMARY_UOM_CODE UOM_CODE,
	0 STK_QTY,
	ROUND (SUM (CIQT.ROLLBACK_QTY),
	4) INT_QTY,
	0 RCV_QTY,
	0 STK_VALUE,
	ROUND (SUM (CIQT.ROLLBACK_QTY) * CICT.ITEM_COST * 1 / 0.0001) * 0.0001
            INT_VALUE,
	0 RCV_VALUE
FROM
	XXXRME_CST_INV_QTY_TEMP CIQT,
	XXXRME_CST_INV_COST_TEMP CICT,
	MTL_PARAMETERS MP,
	MTL_SYSTEM_ITEMS_B MSI,
	apps.MTL_CATEGORIES MC
WHERE
	CIQT.QTY_SOURCE IN (6, 7, 8)
	--     AND CICT.ORGANIZATION_ID = NVL ( :P_ORG_ID, CICT.ORGANIZATION_ID)
	AND CICT.COST_SOURCE IN (1, 2)
	AND CICT.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND CICT.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND MP.PRIMARY_COST_METHOD = 1
	AND MP.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND MSI.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND MSI.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND MC.CATEGORY_ID = CIQT.CATEGORY_ID
GROUP BY
	CIQT.ORGANIZATION_ID,
	MSI.description,
	MSI.PRIMARY_UOM_CODE,
	CICT.ITEM_COST
HAVING
	SUM (CIQT.ROLLBACK_QTY) <> 0
UNION ALL
  SELECT
	CIQT.ORGANIZATION_ID,
	MSI.description DESCRIPTION,
	MSI.PRIMARY_UOM_CODE UOM_CODE,
	0 STK_QTY,
	0 INT_QTY,
	ROUND (SUM (CIQT.ROLLBACK_QTY),
	4) RCV_QTY,
	0 STK_VALUE,
	0 INT_VALUE,
	ROUND (SUM (CIQT.ROLLBACK_QTY) * CICT.ITEM_COST * 1 / 0.0001) * 0.0001
            RCV_VALUE
FROM
	XXXRME_CST_INV_QTY_TEMP CIQT,
	XXXRME_CST_INV_COST_TEMP CICT,
	MTL_SYSTEM_ITEMS_B MSI,
	apps.MTL_CATEGORIES MC
WHERE
	CIQT.QTY_SOURCE IN (9, 10)
	AND CICT.COST_SOURCE IN (3, 4)
	AND CICT.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND CICT.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND CICT.RCV_TRANSACTION_ID = CIQT.RCV_TRANSACTION_ID
	AND MSI.ORGANIZATION_ID = CIQT.ORGANIZATION_ID
	AND MSI.INVENTORY_ITEM_ID = CIQT.INVENTORY_ITEM_ID
	AND MC.CATEGORY_ID = CIQT.CATEGORY_ID
GROUP BY
	CIQT.ORGANIZATION_ID,
	MSI.description,
	MSI.PRIMARY_UOM_CODE,
	CICT.ITEM_COST
HAVING
	SUM (CIQT.ROLLBACK_QTY) <> 0
)  temp """


def RME_All_Inventories_Value_ETL():
    spark = fx.spark_app('RME_All_Inventories_Value','4g','4')
    RES = fx.connection(spark,'RES','RMEDB',RME_All_Inventories_Value_query,'TEMP','ERP')
    fx.WriteFunction(RES ,load_connection_string,'RME_All_Inventories_Value_Report','overwrite',conn.mysql_username,conn.mysql_password)    

local_tz = pendulum.timezone("Europe/Helsinki")
default_args = {'owner' : 'gamal',
                'start_date' : datetime(2024,11,14, tzinfo=local_tz),"retries": 1,
                 "retry_delay": timedelta(minutes=30),'email': ['mohamed.Ghassan@rowad-rme.com'],
                  'email_on_failure': True,
                  'email_on_retry': False,}
dag = DAG('RME_All_Inventories_Value',catchup=False,default_args=default_args,schedule_interval='40 4 * * *',tags=['4'])


RME_All_Inventories_ValueTask= PythonOperator(dag=dag,
                task_id = 'RME_All_Inventories_Value',
                python_callable=RME_All_Inventories_Value_ETL) 


RME_All_Inventories_ValueTask
